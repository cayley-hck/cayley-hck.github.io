<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录前进的脚步"><title>redis配置 | 凯旋</title><link rel="stylesheet" type="text/css" href="/css/normalize.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/pure-min.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">redis配置</h1><a id="logo" href="/.">凯旋</a><p class="description">cayley的博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">redis配置</h1><div class="post-meta"><i class="fa fa-calendar"> 2016-07-03</i></div><span data-disqus-identifier="2016/07/03/redis配置/" class="disqus-comment-count"></span><div class="post-content"><p>redis配置：</p>
<p>使用方法：</p>
<p>1）使用文件：在启动service是使用文件<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/redis/</span>bin<span class="regexp">/redis-server /</span>config.conf</span><br></pre></td></tr></table></figure></p>
<p>2）启动redis后在程序中配置<br>通过config set config_name  config_value 设置<br>通过config get config_name :(*表示所有)</p>
<p>配置说明：</p>
<p>常用</p>
<ol>
<li><p>Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize</span><br></pre></td></tr></table></figure>
</li>
<li><p>当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidfile /<span class="keyword">var</span>/<span class="keyword">run</span>/redis.pid</span><br></pre></td></tr></table></figure></li>
<li>指定Redis监听端口，默认端口为6379，如果你设为 0 ，redis 将不在 socket 上监听任何客户端连接<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="foreign"><span class="keyword">port</span> 6379</span></span><br></pre></td></tr></table></figure></li>
<li><p>绑定的主机地址  示例，多个IP用空格隔开:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
<p>5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 </p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">timeout</span> <span class="number">300</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指定日志记录级别，Redis总共支持四个级别：debug（测试环境）、verbose、notice（生产环境）、warning（仅一些重要的信息），默认为verbose</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">loglevel</span> verbose</span><br></pre></td></tr></table></figure>
</li>
<li><p>日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logfile <span class="built_in">stdout</span></span><br></pre></td></tr></table></figure>
<p>要想把日志记录到系统日志，就把它改成 yes，<br>也可以可选择性的更新其他的syslog 参数以达到你的要求<br>syslog-enabled no</p>
<p>设置 syslog 的 identity。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- more --&gt;</span></span><br><span class="line"></span><br><span class="line"> syslog-ident redis</span><br></pre></td></tr></table></figure>
<p>设置 syslog 的 facility，必须是 USER 或者是 LOCAL0-LOCAL7 之间的值。<br>syslog-facility local0</p>
</li>
<li>设置数据库的数量，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">databases <span class="number">16</span></span><br></pre></td></tr></table></figure>
</dbid></li>
</ol>
<p>快照备份：</p>
<ol>
<li><p>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"></span><br><span class="line">Redis默认配置文件中提供了三个条件：</span><br><span class="line"></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p> 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</p>
<p>注意：你可以注释掉所有的 save 行来停用保存功能。<br>也可以直接一个空字符串来实现停用：</p>
</li>
</ol>
<ol>
<li><p>默认情况下，如果 redis 最后一次的后台保存失败，redis 将停止接受写操作，</p>
<p>这样以一种强硬的方式让用户知道数据不能正确的持久化到磁盘，<br>否则就会没人注意到灾难的发生。</p>
<p>如果后台保存进程重新启动工作了，redis 也将自动的允许写操作。</p>
<p>然而你要是安装了靠谱的监控，你可能不希望 redis 这样做，那你就改成 no 好了。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop-writes-<span class="function_start"><span class="keyword">on</span></span>-bgsave-<span class="keyword">error</span> yes</span><br></pre></td></tr></table></figure></li>
<li>指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">rdbcompression</span> <span class="built_in">yes</span></span><br></pre></td></tr></table></figure></li>
<li>指定本地数据库文件名，默认值为dump.rdb<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">dbfilename</span> <span class="tag">dump</span><span class="class">.rdb</span></span><br></pre></td></tr></table></figure></li>
<li><p>指定本地数据库存放目录</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span> ./</span><br></pre></td></tr></table></figure>
<p>主从复制</p>
<p>主从复制。使用 slaveof 来让一个 redis 实例成为另一个reids 实例的副本。<br>注意这个只需要在 slave 上配置。</p>
</li>
<li>设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof <span class="tag">&lt;<span class="title">masterip</span>&gt;</span> <span class="tag">&lt;<span class="title">masterport</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>当master服务设置了密码保护时，slav服务连接master的密码</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth <span class="tag">&lt;<span class="title">master-password</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>16.是否返回同步不及时的时候的信息<br>当一个 slave 与 master 失去联系，或者复制正在进行的时候，<br>slave 可能会有两种表现：</p>
<p>1) 如果为 yes ，slave 仍然会应答客户端请求，但返回的数据可能是过时，<br>或者数据可能是空的在第一次同步的时候</p>
<p>2) 如果为 no ，在你执行除了 info he salveof 之外的其他命令时，<br>slave 都将返回一个 “SYNC with master in progress” 的错误，</p>
</li>
</ol>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">slave</span>-serve-stale-<span class="typedef"><span class="keyword">data</span> yes</span></span><br></pre></td></tr></table></figure>
<p>17.配置一个 slave 实体是否接受写入操作。<br> 通过写入操作来存储一些短暂的数据对于一个 slave 实例来说可能是有用的，<br> 因为相对从 master 重新同步数而言，据数据写入到 slave 会更容易被删除。<br> 但是如果客户端因为一个错误的配置写入，也可能会导致一些问题。<br> 从 redis 2.6 版起，默认 slaves 都是只读的。<br> 注意：只读的 slaves 没有被设计成在 internet 上暴露给不受信任的客户端。<br> 它仅仅是一个针对误用实例的一个保护层。<br>slave-read-only yes</p>
<p>18.Slaves 在一个预定义的时间间隔内发送 ping 命令到 server 。<br> 你可以改变这个时间间隔。默认为 10 秒。<br> 为确认主库是否可用<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-<span class="built_in">ping</span>-slave-period <span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>设置主从复制过期时间<br>这个值一定要比 repl-ping-slave-period 大</li>
</ol>
<h1 id="repl-timeout-60"><a href="#repl-timeout-60" class="headerlink" title="repl-timeout 60"></a>repl-timeout 60</h1><p>20。  Disable TCP_NODELAY on the slave socket after SYNC?<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># If you <span class="operator"><span class="keyword">select</span> <span class="string">"yes"</span> Redis will <span class="keyword">use</span> a smaller <span class="built_in">number</span> <span class="keyword">of</span> TCP packets <span class="keyword">and</span></span><br><span class="line"># <span class="keyword">less</span> bandwidth <span class="keyword">to</span> send <span class="keyword">data</span> <span class="keyword">to</span> slaves. But this can <span class="keyword">add</span> a delay <span class="keyword">for</span></span><br><span class="line"># the <span class="keyword">data</span> <span class="keyword">to</span> appear <span class="keyword">on</span> the <span class="keyword">slave</span> side, up <span class="keyword">to</span> <span class="number">40</span> milliseconds <span class="keyword">with</span></span><br><span class="line"># Linux kernels <span class="keyword">using</span> a <span class="keyword">default</span> configuration.</span><br><span class="line">#</span><br><span class="line"># <span class="keyword">If</span> you <span class="keyword">select</span> <span class="string">"no"</span> the delay <span class="keyword">for</span> <span class="keyword">data</span> <span class="keyword">to</span> appear <span class="keyword">on</span> the <span class="keyword">slave</span> side will</span><br><span class="line"># be <span class="keyword">reduced</span> but more bandwidth will be used <span class="keyword">for</span> <span class="keyword">replication</span>.</span><br><span class="line">#</span><br><span class="line"># <span class="keyword">By</span> <span class="keyword">default</span> we <span class="keyword">optimize</span> <span class="keyword">for</span> <span class="keyword">low</span> latency, but <span class="keyword">in</span> very <span class="keyword">high</span> traffic conditions</span><br><span class="line"># <span class="keyword">or</span> <span class="keyword">when</span> the <span class="keyword">master</span> <span class="keyword">and</span> slaves <span class="keyword">are</span> many hops away, turning this <span class="keyword">to</span> <span class="string">"yes"</span> may</span><br><span class="line"># be a good idea.</span><br><span class="line">repl-<span class="keyword">disable</span>-tcp-<span class="keyword">nodelay</span> <span class="keyword">no</span></span></span><br></pre></td></tr></table></figure><br>21.设置主从复制容量大小。这个 backlog 是一个用来在 slaves 被断开连接时<br> 存放 slave 数据的 buffer，所以当一个 slave 想要重新连接，通常不希望全部重新同步，<br> 只是部分同步就够了，仅仅传递 slave 在断开连接时丢失的这部分数据。<br> 这个值越大，salve 可以断开连接的时间就越长。</p>
<h1 id="repl-backlog-size-1mb"><a href="#repl-backlog-size-1mb" class="headerlink" title="repl-backlog-size 1mb"></a>repl-backlog-size 1mb</h1><p>22.在某些时候，master 不再连接 slaves，backlog 将被释放<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># A value of 0 means to never release the backlog.</span></span><br><span class="line"><span class="preprocessor"># 如果设置为 0 ，意味着绝不释放 backlog 。</span></span><br><span class="line"><span class="preprocessor">#</span></span><br><span class="line"><span class="preprocessor"># repl-backlog-ttl 3600</span></span><br></pre></td></tr></table></figure><br>23当 master 不能正常工作的时候，Redis Sentinel 会从 slaves 中选出一个新的 master，<br> 这个值越小，就越会被优先选中，但是如果是 0 ， 那是意味着这个 slave 不可能被选中。<br> 默认优先级为 100。<br>slave-priority 100<br>安全：</p>
<ol>
<li><p>设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭</password></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">requirepass</span> foobared</span><br></pre></td></tr></table></figure>
<p>限制：</p>
</li>
<li><p>设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxclients <span class="number">128</span></span><br></pre></td></tr></table></figure></li>
<li>指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory <span class="tag">&lt;<span class="title">bytes</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>最大内存策略，你有 5 个选择。<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># </span></span><br><span class="line"><span class="preprocessor"># volatile-lru -&gt; 使用 LRU 算法移除包含过期设置的 key 。</span></span><br><span class="line"><span class="preprocessor"># allkeys-lru -&gt; 根据 LRU 算法移除所有的 key 。</span></span><br><span class="line"><span class="preprocessor"># volatile-random -&gt; remove a random key with an expire set：移除随机包含过期设置的key</span></span><br><span class="line"><span class="preprocessor"># allkeys-random -&gt; remove a random key, any key:移除随机所有过期设置的key</span></span><br><span class="line"><span class="preprocessor"># volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL)移除随机最近过期的key</span></span><br><span class="line"><span class="preprocessor"># noeviction -&gt; 不让任何 key 过期，只是给写入操作返回一个错误</span></span><br><span class="line"><span class="preprocessor">#</span></span><br><span class="line"><span class="preprocessor"># The default is:</span></span><br><span class="line"><span class="preprocessor">#</span></span><br><span class="line"><span class="preprocessor"># maxmemory-policy noeviction</span></span><br></pre></td></tr></table></figure></li>
<li>指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">appendonly</span> <span class="built_in">no</span></span><br></pre></td></tr></table></figure></li>
<li>指定更新日志文件名，默认为appendonly.aof<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">appendfilename</span> <span class="tag">appendonly</span><span class="class">.aof</span></span><br></pre></td></tr></table></figure></li>
<li>指定更新日志条件，共有3个可选值：<br>no：表示等操作系统进行数据缓存同步到磁盘（快）<br>always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）<br>everysec：表示每秒同步一次（折衷，默认值）<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">appendfsync</span> everysec</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>31.AOF策略设置为always或者everysec时，后台处理进程(后台保存或者AOF日志重写)会执行大量的I/O操作<br>在某些Linux配置中会阻止过长的fsync()请求。注意现在没有任何修复，即使fsync在另外一个线程进行处理<br>为了减缓这个问题，可以设置下面这个参数no-appendfsync-on-rewrite<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">no</span>-appendfsync-<span class="literal">on</span>-rewrite <span class="literal">no</span></span><br></pre></td></tr></table></figure><br>32.AOF 自动重写</p>
<p>当AOF文件增长到一定大小的时候Redis能够调用 BGREWRITEAOF 对日志文件进行重写<br>它是这样工作的：Redis会记住上次进行些日志后文件的大小(如果从开机以来还没进行过重写，那日子大小在开机的时候确定)<br>基础大小会同现在的大小进行比较。如果现在的大小比基础大小大制定的百分比，重写功能将启动<br>同时需要指定一个最小大小用于AOF重写，这个用于阻止即使文件很小但是增长幅度很大也去重写AOF文件的情况</p>
<h1 id="设置-percentage"><a href="#设置-percentage" class="headerlink" title="设置 percentage"></a>设置 percentage</h1><p>为0就关闭这个特性<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>-aof-rewrite-min-size <span class="number">64</span>mb</span><br></pre></td></tr></table></figure><br>日志：</p>
<p> Redis Slow Log 记录超过特定执行时间的命令。执行时间不包括I/O计算比如连接客户端，返回结果等，只是命令执行时间</p>
<p>可以通过两个参数设置slow log：一个是告诉Redis执行超过多少时间被记录的参数slowlog-log-slower-than(微妙)，<br>另一个是slow log 的长度。当一个新命令被记录的时候最早的命令将被从队列中移除<br> 下面的时间以微妙微单位，因此1000000代表一分钟。</p>
<p>33注意制定一个负数将关闭慢日志，而设置为0将强制每个命令都会记录<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slowlog-<span class="built_in">log</span>-slower-than <span class="number">10000</span></span><br></pre></td></tr></table></figure><br>34对日志长度没有限制，只是要注意它会消耗内存<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以通过 SLOWLOG RESET </span></span><br><span class="line">回收被慢日志消耗的内存</span><br><span class="line">slowlog-<span class="built_in">max</span>-<span class="built_in">len</span> <span class="number">1024</span></span><br></pre></td></tr></table></figure><br>VM:</p>
<ol>
<li>指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vm</span>-enabled <span class="keyword">no</span></span><br></pre></td></tr></table></figure></li>
<li>虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm-swap-<span class="keyword">file</span> <span class="regexp">/tmp/</span>redis.swap</span><br></pre></td></tr></table></figure></li>
<li>将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm-<span class="keyword">max</span>-<span class="keyword">memory</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li>Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm-page-size <span class="number">32</span></span><br></pre></td></tr></table></figure></li>
<li>设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm-pages <span class="number">134217728</span></span><br></pre></td></tr></table></figure></li>
<li>设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vm</span>-<span class="built_in">max</span>-threads <span class="number">4</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>lua脚本：</p>
<p>41.执行lua脚本的超时时间<br>lua-time-limit 5000</p>
<p>集群：<br>42.启用或停用集群</p>
<h1 id="cluster-enabled-yes"><a href="#cluster-enabled-yes" class="headerlink" title="cluster-enabled yes"></a>cluster-enabled yes</h1><p>43.集群配置文件</p>
<h1 id="cluster-config-file-nodes-6379-conf"><a href="#cluster-config-file-nodes-6379-conf" class="headerlink" title="cluster-config-file nodes-6379.conf"></a>cluster-config-file nodes-6379.conf</h1><p>44.节点超时时间<br> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"># cluster-node-timeout 15000</span><br><span class="line"> </span><br><span class="line"># A slave of a failing master will avoid to <span class="operator"><span class="keyword">start</span> a <span class="keyword">failover</span> <span class="keyword">if</span> its <span class="keyword">data</span></span><br><span class="line"># looks too <span class="keyword">old</span>.</span><br><span class="line">#</span><br><span class="line"># There <span class="keyword">is</span> <span class="keyword">no</span> simple way <span class="keyword">for</span> a <span class="keyword">slave</span> <span class="keyword">to</span> actually have a exact measure <span class="keyword">of</span></span><br><span class="line"># its <span class="string">"data age"</span>, so the <span class="keyword">following</span> two checks <span class="keyword">are</span> performed:</span><br><span class="line">#</span><br><span class="line"># <span class="number">1</span>) <span class="keyword">If</span> there <span class="keyword">are</span> multiple slaves able <span class="keyword">to</span> <span class="keyword">failover</span>, they <span class="keyword">exchange</span> messages</span><br><span class="line">#    <span class="keyword">in</span> <span class="keyword">order</span> <span class="keyword">to</span> try <span class="keyword">to</span> give an advantage <span class="keyword">to</span> the <span class="keyword">slave</span> <span class="keyword">with</span> the best</span><br><span class="line">#    <span class="keyword">replication</span> <span class="keyword">offset</span> (more <span class="keyword">data</span> <span class="keyword">from</span> the <span class="keyword">master</span> processed).</span><br><span class="line">#    Slaves will try <span class="keyword">to</span> <span class="keyword">get</span> their <span class="keyword">rank</span> <span class="keyword">by</span> <span class="keyword">offset</span>, <span class="keyword">and</span> <span class="keyword">apply</span> <span class="keyword">to</span> the <span class="keyword">start</span></span><br><span class="line">#    <span class="keyword">of</span> the <span class="keyword">failover</span> a delay proportional <span class="keyword">to</span> their <span class="keyword">rank</span>.</span><br><span class="line">#</span><br><span class="line"># <span class="number">2</span>) Every single <span class="keyword">slave</span> computes the <span class="keyword">time</span> <span class="keyword">of</span> the <span class="keyword">last</span> interaction <span class="keyword">with</span></span><br><span class="line">#    its <span class="keyword">master</span>. This can be the <span class="keyword">last</span> ping <span class="keyword">or</span> command received (<span class="keyword">if</span> the <span class="keyword">master</span></span><br><span class="line">#    <span class="keyword">is</span> still <span class="keyword">in</span> the <span class="string">"connected"</span> state), <span class="keyword">or</span> the <span class="keyword">time</span> that elapsed since the</span><br><span class="line">#    disconnection <span class="keyword">with</span> the <span class="keyword">master</span> (<span class="keyword">if</span> the <span class="keyword">replication</span> <span class="keyword">link</span> <span class="keyword">is</span> currently down).</span><br><span class="line">#    <span class="keyword">If</span> the <span class="keyword">last</span> interaction <span class="keyword">is</span> too <span class="keyword">old</span>, the <span class="keyword">slave</span> will <span class="keyword">not</span> try <span class="keyword">to</span> <span class="keyword">failover</span></span><br><span class="line">#    <span class="keyword">at</span> all.</span><br><span class="line">#</span><br><span class="line"># The point <span class="string">"2"</span> can be tuned <span class="keyword">by</span> <span class="keyword">user</span>. Specifically a <span class="keyword">slave</span> will <span class="keyword">not</span> perform</span><br><span class="line"># the <span class="keyword">failover</span> <span class="keyword">if</span>, since the <span class="keyword">last</span> interaction <span class="keyword">with</span> the <span class="keyword">master</span>, the <span class="keyword">time</span></span><br><span class="line"># elapsed <span class="keyword">is</span> greater <span class="keyword">than</span>:</span><br><span class="line">#</span><br><span class="line">#   (node-<span class="keyword">timeout</span> * <span class="keyword">slave</span>-validity-factor) + repl-ping-<span class="keyword">slave</span>-<span class="keyword">period</span></span><br><span class="line">#</span><br><span class="line"># So <span class="keyword">for</span> example <span class="keyword">if</span> node-<span class="keyword">timeout</span> <span class="keyword">is</span> <span class="number">30</span> seconds, <span class="keyword">and</span> the <span class="keyword">slave</span>-validity-factor</span><br><span class="line"># <span class="keyword">is</span> <span class="number">10</span>, <span class="keyword">and</span> assuming a <span class="keyword">default</span> repl-ping-<span class="keyword">slave</span>-<span class="keyword">period</span> <span class="keyword">of</span> <span class="number">10</span> seconds, the</span><br><span class="line"># <span class="keyword">slave</span> will <span class="keyword">not</span> try <span class="keyword">to</span> <span class="keyword">failover</span> <span class="keyword">if</span> it was <span class="keyword">not</span> able <span class="keyword">to</span> talk <span class="keyword">with</span> the <span class="keyword">master</span></span><br><span class="line"># <span class="keyword">for</span> longer <span class="keyword">than</span> <span class="number">310</span> seconds.</span><br><span class="line">#</span><br><span class="line"># A <span class="keyword">large</span> <span class="keyword">slave</span>-validity-factor may <span class="keyword">allow</span> slaves <span class="keyword">with</span> too <span class="keyword">old</span> <span class="keyword">data</span> <span class="keyword">to</span> <span class="keyword">failover</span></span><br><span class="line"># a <span class="keyword">master</span>, <span class="keyword">while</span> a too small <span class="keyword">value</span> may prevent the cluster <span class="keyword">from</span> being able <span class="keyword">to</span></span><br><span class="line"># elect a <span class="keyword">slave</span> <span class="keyword">at</span> all.</span><br><span class="line">#</span><br><span class="line"># <span class="keyword">For</span> maximum <span class="keyword">availability</span>, it <span class="keyword">is</span> possible <span class="keyword">to</span> <span class="keyword">set</span> the <span class="keyword">slave</span>-validity-factor</span><br><span class="line"># <span class="keyword">to</span> a <span class="keyword">value</span> <span class="keyword">of</span> <span class="number">0</span>, which means, that slaves will <span class="keyword">always</span> try <span class="keyword">to</span> <span class="keyword">failover</span> the</span><br><span class="line"># <span class="keyword">master</span> regardless <span class="keyword">of</span> the <span class="keyword">last</span> <span class="keyword">time</span> they interacted <span class="keyword">with</span> the <span class="keyword">master</span>.</span><br><span class="line"># (However they<span class="string">'ll always try to apply a delay proportional to their</span><br><span class="line"># offset rank).</span><br><span class="line">#</span><br><span class="line"># Zero is the only value able to guarantee that when all the partitions heal</span><br><span class="line"># the cluster will always be able to continue.</span><br><span class="line">#</span><br><span class="line"># cluster-slave-validity-factor 10</span><br><span class="line"> </span><br><span class="line"># Cluster slaves are able to migrate to orphaned masters, that are masters</span><br><span class="line"># that are left without working slaves. This improves the cluster ability</span><br><span class="line"># to resist to failures as otherwise an orphaned master can'</span><span class="keyword">t</span> be <span class="keyword">failed</span> <span class="keyword">over</span></span><br><span class="line"># <span class="keyword">in</span> <span class="keyword">case</span> <span class="keyword">of</span> <span class="keyword">failure</span> <span class="keyword">if</span> it has <span class="keyword">no</span> working slaves.</span><br><span class="line">#</span><br><span class="line"># Slaves migrate <span class="keyword">to</span> orphaned masters <span class="keyword">only</span> <span class="keyword">if</span> there <span class="keyword">are</span> still <span class="keyword">at</span> <span class="keyword">least</span> a</span><br><span class="line"># given <span class="built_in">number</span> <span class="keyword">of</span> other working slaves <span class="keyword">for</span> their <span class="keyword">old</span> <span class="keyword">master</span>. This <span class="built_in">number</span></span><br><span class="line"># <span class="keyword">is</span> the <span class="string">"migration barrier"</span>. A <span class="keyword">migration</span> barrier <span class="keyword">of</span> <span class="number">1</span> means that a <span class="keyword">slave</span></span><br><span class="line"># will migrate <span class="keyword">only</span> <span class="keyword">if</span> there <span class="keyword">is</span> <span class="keyword">at</span> <span class="keyword">least</span> <span class="number">1</span> other working <span class="keyword">slave</span> <span class="keyword">for</span> its <span class="keyword">master</span></span><br><span class="line"># <span class="keyword">and</span> so forth. It usually reflects the <span class="built_in">number</span> <span class="keyword">of</span> slaves you want <span class="keyword">for</span> every</span><br><span class="line"># <span class="keyword">master</span> <span class="keyword">in</span> your cluster.</span><br><span class="line">#</span><br><span class="line"># <span class="keyword">Default</span> <span class="keyword">is</span> <span class="number">1</span> (slaves migrate <span class="keyword">only</span> <span class="keyword">if</span> their masters remain <span class="keyword">with</span> <span class="keyword">at</span> <span class="keyword">least</span></span><br><span class="line"># one <span class="keyword">slave</span>). <span class="keyword">To</span> <span class="keyword">disable</span> <span class="keyword">migration</span> just <span class="keyword">set</span> it <span class="keyword">to</span> a very <span class="keyword">large</span> <span class="keyword">value</span>.</span><br><span class="line"># A <span class="keyword">value</span> <span class="keyword">of</span> <span class="number">0</span> can be <span class="keyword">set</span> but <span class="keyword">is</span> useful <span class="keyword">only</span> <span class="keyword">for</span> debugging <span class="keyword">and</span> dangerous</span><br><span class="line"># <span class="keyword">in</span> production.</span><br><span class="line">#</span><br><span class="line"># cluster-<span class="keyword">migration</span>-barrier <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"># <span class="keyword">In</span> <span class="keyword">order</span> <span class="keyword">to</span> setup your cluster make sure <span class="keyword">to</span> <span class="keyword">read</span> the documentation</span><br><span class="line"># available <span class="keyword">at</span> <span class="keyword">http</span>://redis.io web site.</span></span><br></pre></td></tr></table></figure></p>
<p>其它：</p>
<ol>
<li>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">glueoutputbuf</span> <span class="built_in">yes</span></span><br></pre></td></tr></table></figure></li>
<li>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hash-<span class="built_in">max</span>-zipmap-entries <span class="number">64</span></span><br><span class="line"></span><br><span class="line">hash-<span class="built_in">max</span>-zipmap-<span class="keyword">value</span> <span class="number">512</span></span><br></pre></td></tr></table></figure></li>
<li>指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">activerehashing</span> <span class="built_in">yes</span></span><br></pre></td></tr></table></figure></li>
<li>指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">include</span> /path/<span class="built_in">to</span>/<span class="built_in">local</span>.conf</span><br></pre></td></tr></table></figure></li>
</ol>
</div><a data-url="http://b.miaoxiaohei.com/2016/07/03/redis配置/" data-id="cir7uxjvb000vjvi0x0pi9cxm" class="article-share-link">分享到</a><div class="tags"></div><div class="post-nav"><a href="/2016/07/03/redis基本命令/" class="pre"><i class="fa fa-caret-left"> redis基本命令</i></a><a href="/2016/07/03/redis安装/" class="next">redis安装 <i class="fa fa-caret-right"></i></a></div><div id="disqus_thread"><script>var disqus_shortname = 'cayleyblogs';
var disqus_identifier = '2016/07/03/redis配置/';
var disqus_title = 'redis配置';
var disqus_url = 'http://b.miaoxiaohei.com/2016/07/03/redis配置/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//cayleyblogs.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="si" value="http://b.miaoxiaohei.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/liunx/">liunx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs/">nodejs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/php/">php</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/composer/" style="font-size: 15px;">composer</a> <a href="/tags/https/" style="font-size: 15px;">https</a> <a href="/tags/科学上网/" style="font-size: 15px;">科学上网</a> <a href="/tags/libiconv/" style="font-size: 15px;">libiconv</a> <a href="/tags/yum/" style="font-size: 15px;">yum</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/07/29/路由宝刷机pandorabox后利用自带存储卡/">路由宝刷机pandorabox后利用自带存储卡</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/27/使用ownCloud搭建云盘/">使用ownCloud搭建云盘</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/27/编译安装libiconv库/">编译安装libiconv库</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/27/使用seafile搭建云盘/">使用seafile搭建云盘</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/17/nginx的使用与配置/">nginx的使用与配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/06/nginx安装分析/">nginx安装分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/03/redis安全/">redis安全</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/03/redis高级命令/">redis高级命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/03/redis基本命令/">redis基本命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/03/redis配置/">redis配置</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//cayleyblogs.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">凯旋.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/jquery.min.js?v=0.0.0"></script><script type="text/javascript" src="/js/totop.js?v=0.0.0"></script><script type="text/javascript" src="/js/fancybox.pack.js?v=0.0.0"></script><script type="text/javascript" src="/js/jquery.fancybox.js?v=0.0.0"></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/share.js?v=0.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>